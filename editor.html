<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="A web-based map editor for quick editing and saving of ROS and ROS2 SLAM maps and keep-out zones.">
  <meta name="keywords" content="online, web, ros, ros2, SLAM, map,, editor, robotics, robots, responsive, pgm">
  <meta name="author" content="Dominick Lee">
  <title>Online ROS2 SLAM Map Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap 4 + Font Awesome 4.7 -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <style>
    body{background:#111;color:#eee}
    .toolbar{position:sticky;top:0;z-index:10;background:#1b1b1b;border-bottom:1px solid #333}
    .overlay-label{position:absolute; top:8px; left:8px; background:rgba(0,0,0,.5); padding:4px 8px; border-radius:4px; font-size:12px}
    .dropzone{border:2px dashed #555; border-radius:6px; padding:12px; text-align:center; color:#bbb}
    .dropzone.drag{background:#222; color:#fff; border-color:#888}
    .small-note{font-size:12px; color:#aaa}
    .spacer{height:12px}
    .tool-btn.active,.shape-btn.active{outline:2px solid #17a2b8}

    /* Viewport that can scroll/pan when the map is larger than the screen */
    #viewport{
      position: relative;
      width: 100%;
      height: calc(100vh - 150px); /* JS refines on load/resize */
      overflow: auto;
      border: 1px solid #333;
      background: #000;
      cursor: default;
    }
    #viewport.panning{ cursor: grab; }
    #viewport.panning.dragging{ cursor: grabbing; }

    /* The canvas stack */
    #canvasWrap{ position:relative; display:inline-block; }

    /* Base map canvas gets the checkerboard */
    #mapCanvas{
      image-rendering: pixelated; image-rendering: crisp-edges;
      border:1px solid #444;
      background: conic-gradient(#222 0 25%, #111 0 50%, #222 0 75%, #111 0 100%) 0 0/16px 16px;
    }
    /* Mask overlay is transparent except where painted */
    #maskCanvas{
      image-rendering: pixelated; image-rendering: crisp-edges;
      border:1px solid #444;
      background: transparent !important;
      position:absolute; left:0; top:0; z-index:2;
      pointer-events: none;
    }
    /* Preview overlay for line/rect ghosting */
    #previewCanvas{
      image-rendering: pixelated; image-rendering: crisp-edges;
      position:absolute; left:0; top:0; z-index:3;
      pointer-events: none;
      background: transparent !important;
    }
    /* Brush cursor */
    #brushCursor{
      position: absolute;
      pointer-events: none;
      border: 1px solid rgba(200,200,200,0.9);
      border-radius: 50%;
      box-sizing: border-box;
      z-index: 4;
      display: none;
    }
	/* YAML preview text */
	#yamlPreview{
      color: #26a7bb !important;
	}
	/* Prevent selection of UI panels */
	.noselect {
	  -webkit-user-select: none; /* Safari */
	  user-select: none; /* Non-prefixed version, 
							supported by all other modern browsers */
	}
  </style>
</head>
<body>
<div class="toolbar p-2">
  <div class="container-fluid">
    <div class="form-row align-items-center">
      <div class="col-auto pb-2">
        <input type="file" id="yamlInput" accept=".yaml,.yml" class="d-none">
        <button class="btn btn-sm btn-outline-info" id="btnLoadYaml"><i class="fa fa-file-text-o"></i> Load YAML</button>
        <span id="yamlName" class="small-note ml-2">No YAML</span>
      </div>
      <div class="col-auto pb-2">
        <input type="file" id="pgmInput" accept=".pgm" class="d-none">
        <button class="btn btn-sm btn-outline-info" id="btnLoadPgm"><i class="fa fa-picture-o"></i> Load PGM</button>
        <span id="pgmName" class="small-note ml-2">No PGM</span>
		<span id="maskName" class="small-note ml-2">No Keepout</span>
      </div>
	  
      <!-- Zoom / Undo-Redo -->
      <div class="col-auto pb-2">
        <div class="btn-group btn-group-sm" role="group" aria-label="Zoom">
          <button class="btn btn-outline-light" id="zoomOut" title="Zoom Out (−)"><i class="fa fa-search-minus"></i></button>
          <button class="btn btn-outline-light" id="zoomIn" title="Zoom In (+)"><i class="fa fa-search-plus"></i></button>
          <button class="btn btn-outline-light" id="zoomReset" title="Reset Zoom"><i class="fa fa-compress"></i></button>
        </div>
        <div class="btn-group btn-group-sm ml-2" role="group">
          <button class="btn btn-outline-warning" id="btnUndo" title="Undo (Ctrl+Z)"><i class="fa fa-undo"></i></button>
          <button class="btn btn-outline-warning" id="btnRedo" title="Redo (Ctrl+Y / Shift+Z)"><i class="fa fa-repeat"></i></button>
        </div>
      </div>

      <!-- Target (which layer / action) -->
      <div class="col-auto pb-2">
        <div class="btn-group btn-group-sm" role="group" aria-label="Tools">
          <button class="btn btn-outline-light tool-btn" data-tool="paint" title="Paint Walls (occupied)"><i class="fa fa-paint-brush"></i> Wall</button>
          <button class="btn btn-outline-light tool-btn" data-tool="erase" title="Erase Map + Keepout"><i class="fa fa-eraser"></i> Erase</button>
		  <button class="btn btn-outline-light tool-btn" data-tool="unscan" title="Mark as unknown (un-scanned)"><i class="fa fa-minus-square-o"></i> Un-Scan</button>
          <button class="btn btn-outline-light tool-btn" data-tool="mask" title="Draw Keepout Mask"><i class="fa fa-ban"></i> Keep-Out</button>
        </div>
      </div>

      <!-- Shape Group -->
      <div class="col-auto pb-2">
        <div class="btn-group btn-group-sm" role="group" aria-label="Shape">
          <button class="btn btn-outline-light shape-btn" data-shape="freehand" title="Freehand"><i class="fa fa-pencil"></i></button>
          <button class="btn btn-outline-light shape-btn" data-shape="line" title="Line"><i class="fa fa-minus"></i></button>
          <button class="btn btn-outline-light shape-btn" data-shape="rect" title="Rectangle"><i class="fa fa-square-o"></i></button>
		  <button class="btn btn-outline-light shape-btn" data-shape="measure" title="Measure Distance"><i class="fa fa-arrows-h"></i></button>
        </div>
      </div>

      <!-- Brush -->
      <div class="col-auto pb-2">
        <label class="mb-0 mr-2"><i class="fa fa-dot-circle-o"></i> Brush</label>
        <input type="range" id="brushSize" min="1" max="60" value="8">
        <span id="brushLabel" class="small-note">8 px</span>
      </div>

      <!-- Display toggles -->
      <div class="col-auto pb-2">
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="checkbox" id="showMask" checked>
          <label class="form-check-label" for="showMask">Show Mask</label>
        </div>
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="checkbox" id="invertDisplay">
          <label class="form-check-label" for="invertDisplay">Invert</label>
        </div>
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="checkbox" id="autoLevels" checked>
          <label class="form-check-label" for="autoLevels">Auto-levels</label>
        </div>
		<div class="form-check form-check-inline">
		  <input class="form-check-input" type="checkbox" id="filledRect">
		  <label class="form-check-label" for="filledRect">Filled</label>
		</div>
      </div>

	  <!-- Download Files -->
      <div class="col-auto pb-2">
        <button class="btn btn-sm btn-success" id="btnDownloadMap"><i class="fa fa-download"></i> Download Map</button>
        <button class="btn btn-sm btn-warning" id="btnDownloadMask"><i class="fa fa-download"></i> Download Keepout Mask</button>
      </div>

      <div class="col small-note ml-auto text-right pb-2">
        Tip: Choose a target (Paint/Erase/Keep-Out), then a shape (Freehand/Line/Rect). Spacebar+Drag to pan. Shift+Scroll to zoom.
      </div>
    </div>
  </div>
</div>

<div class="container-fluid mt-3">
  <div class="row">
    <div class="col-lg-3 mb-3">
      <div id="drop" class="dropzone noselect">
        <div><strong>Drag & drop</strong> your <code>.yaml</code> and <code>.pgm</code> here</div>
        <div class="small-note">…or use the buttons above</div>
      </div>
      <div class="spacer"></div>
      <div class="card bg-dark">
        <div class="card-body p-2">
          <div class="small-note">YAML preview</div>
          <pre id="yamlPreview" class="mb-0" style="max-height:240px; overflow:auto;"></pre>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="card bg-dark">
        <div class="card-body p-2">
          <div class="small-note">Debug</div>
          <div class="small-note" id="dbgInfo">—</div>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="card bg-dark">
        <div class="card-body p-2 noselect">
          <div class="small-note mb-2"><strong>Legend</strong></div>
          <div class="small-note"><i class="fa fa-paint-brush"></i> Wall: Sets map pixels to <code>0</code> (occupied/black)</div>
          <div class="small-note"><i class="fa fa-eraser"></i> Erase: map→<code>maxval</code> (free), mask→<code>255</code> (no-keepout)</div>
		  <div class="small-note"><i class="fa fa-minus-square-o"></i> &nbsp;Un-Scan: Sets map pixels to light gray (unknown)</div>
          <div class="small-note"><i class="fa fa-ban"></i> &nbsp;Keep-Out: Draws black on mask (keepout)</div>
		  <div class="spacer"></div>
		  <div class="small-note mt-3"><i>Powered by GyroPalm VIMPAACT</i></div>
        </div>
      </div>
    </div>

    <div class="col-lg-9">
      <div id="viewport">
        <div id="canvasWrap">
          <div class="overlay-label">Map</div>
          <canvas id="mapCanvas"></canvas>
          <canvas id="maskCanvas"></canvas>
          <canvas id="previewCanvas"></canvas>
          <div id="brushCursor"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- jQuery + Bootstrap 4 + js-yaml -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<script>
(function(){
  // ===== State =====
  let yamlObj = null, yamlText = '', yamlName = 'map.yaml';
  let pgm = null, pgmName = 'map.pgm';
  let mask = null; // Uint8ClampedArray (0=keepout, 255=no keepout)

  let tool = 'paint';               // target: 'paint' | 'erase' | 'mask'
  let shape = 'freehand';           // 'freehand' | 'line' | 'rect'
  let drawing = false;
  let previewing = false;
  let brush = 8;
  let zoom = 1, ZMIN=0.25, ZMAX=8, ZSTEP=1.25;
  
  let maskName = 'No Keepout';      // track which mask file is loaded
  
  // filename helpers
  const isYaml = name => /\.ya?ml$/i.test(name);
  const isPgm  = name => /\.pgm$/i.test(name);
  const isKeepoutName = name => /_keepout\.(pgm|ya?ml)$/i.test(name) || /keepout/i.test(name);

  // Panning
  let isSpace = false, panning = false;
  let panStartX=0, panStartY=0, panStartScrollL=0, panStartScrollT=0;

  // Undo/Redo stacks
  const undoStack = [];  // each: [{layer, idx, prev, next}, ...]
  const redoStack = [];
  let currentStroke = null;
  let touchedIndices = null;

  // Shape start point (canvas coords)
  let sx=0, sy=0;
  
  // Filled rectangle
  let filledRect = false;
  
  $('#filledRect').on('change', function(){
    filledRect = this.checked;
    // clear any ghost preview when toggling fill
    clearPreview();
  });
  
  $('#filledRect').prop('checked', false);

  // ===== Elements =====
  const $yamlName = $('#yamlName'), $pgmName = $('#pgmName');
  const mapCanvas = document.getElementById('mapCanvas');
  const maskCanvas = document.getElementById('maskCanvas');
  const previewCanvas = document.getElementById('previewCanvas');
  const mapCtx = mapCanvas.getContext('2d');
  const maskCtx = maskCanvas.getContext('2d');
  const prevCtx = previewCanvas.getContext('2d');
  const brushCursor = document.getElementById('brushCursor');
  const viewport = document.getElementById('viewport');
  const canvasWrap = document.getElementById('canvasWrap');

  // ===== UI Handlers =====
  $('.tool-btn').on('click', function(){
    $('.tool-btn').removeClass('active'); $(this).addClass('active');
    tool = $(this).data('tool');
  });
  $('.tool-btn[data-tool="paint"]').addClass('active');

  $('.shape-btn').on('click', function(){
    $('.shape-btn').removeClass('active'); $(this).addClass('active');
    shape = $(this).data('shape');
    clearPreview();
  });
  $('.shape-btn[data-shape="freehand"]').addClass('active');

  $('#brushSize').on('input change', function(){
    brush = parseInt(this.value,10);
    $('#brushLabel').text(brush + ' px');
    updateBrushCursorSize();
  });

  $('#showMask').on('change', function(){
    maskCanvas.style.display = this.checked ? 'block' : 'none';
    redrawMask();
  });
  $('#invertDisplay, #autoLevels').on('change', ()=> redrawMap());

  $('#btnLoadYaml').on('click', () => $('#yamlInput').click());
  $('#btnLoadPgm').on('click', () => $('#pgmInput').click());
  $('#yamlInput').on('change', e => handleFiles(e.target.files));
  $('#pgmInput').on('change', e => handleFiles(e.target.files));

  // Zoom controls
  $('#zoomIn').on('click', ()=> setZoom(Math.min(ZMAX, zoom*ZSTEP)));
  $('#zoomOut').on('click', ()=> setZoom(Math.max(ZMIN, zoom/ZSTEP)));
  $('#zoomReset').on('click', ()=> setZoom(1));

  // Undo/Redo
  $('#btnUndo').on('click', undo);
  $('#btnRedo').on('click', redo);

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.target && /input|textarea|select/i.test(e.target.tagName)) return;

    if(e.code === 'Space'){
      if(!isSpace){ e.preventDefault(); isSpace = true; viewport.classList.add('panning'); }
    } else if(e.key === '+' || e.key === '='){ setZoom(Math.min(ZMAX, zoom*ZSTEP)); }
    else if(e.key === '-' || e.key === '_'){ setZoom(Math.max(ZMIN, zoom/ZSTEP)); }
    else if(e.key === '0'){ setZoom(1); }
    else if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){ e.preventDefault(); undo(); }
    else if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y'){ e.preventDefault(); redo(); }
    else if(e.shiftKey && e.key.toLowerCase() === 'z'){ e.preventDefault(); redo(); }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code === 'Space'){ isSpace = false; viewport.classList.remove('panning'); viewport.classList.remove('dragging'); }
  });

  // Resize viewport height precisely relative to toolbar
  function sizeViewport(){
    const toolbarH = document.querySelector('.toolbar').offsetHeight;
    viewport.style.height = Math.max(200, window.innerHeight - toolbarH - 16) + 'px';
  }
  window.addEventListener('resize', sizeViewport);
  sizeViewport();

  // ===== Drag & Drop =====
  const drop = document.getElementById('drop');
  const stop = e => { e.preventDefault(); e.stopPropagation(); };
  ['dragenter','dragover','dragleave','drop'].forEach(n => drop.addEventListener(n, stop, false));
  drop.addEventListener('dragover', () => drop.classList.add('drag'));
  drop.addEventListener('dragleave', () => drop.classList.remove('drag'));
  drop.addEventListener('drop', (e)=>{
    drop.classList.remove('drag');
    handleFiles(e.dataTransfer.files);
  });

  // ===== Canvas sizing & zoom =====
  function setZoom(z){
    if(!pgm) return;
    zoom = z;
    const w = Math.round(pgm.width * zoom);
    const h = Math.round(pgm.height * zoom);
    [mapCanvas, maskCanvas, previewCanvas].forEach(cv => { cv.width = w; cv.height = h; });
    redrawMap(); redrawMask(); clearPreview();
    updateBrushCursorSize();
  }
  
  // ===== Canvas focused zoom helper using Shift+Scroll =====
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  
    // Zoom keeping the cursor position anchored
  function zoomAtClient(clientX, clientY, factor){
    if(!pgm) return;
  
    const vpRect = viewport.getBoundingClientRect();
    const vx = clientX - vpRect.left;   // cursor relative to viewport
    const vy = clientY - vpRect.top;
  
    // Canvas coords under cursor BEFORE zoom
    const cxBefore = viewport.scrollLeft + vx;
    const cyBefore = viewport.scrollTop  + vy;
    const mx = cxBefore / zoom; // map pixels under cursor
    const my = cyBefore / zoom;
  
    // Apply zoom
    const newZoom = clamp(zoom * factor, ZMIN, ZMAX);
    if(newZoom === zoom) return;
    setZoom(newZoom);
  
    // AFTER zoom, compute needed scroll so that (mx,my) stays under cursor
    const cxAfter = mx * zoom;
    const cyAfter = my * zoom;
    viewport.scrollLeft = Math.round(cxAfter - vx);
    viewport.scrollTop  = Math.round(cyAfter - vy);
  }

  viewport.addEventListener('wheel', (e)=>{
    if(!pgm) return;
    if(e.shiftKey){
      e.preventDefault(); // avoid page scroll
      const factor = (e.deltaY < 0) ? ZSTEP : (1 / ZSTEP);
      zoomAtClient(e.clientX, e.clientY, factor);
    }
  }, {passive:false});


  // ===== Coordinate transforms (canvas pixel -> map pixel) =====
  function canvasToMap(cx, cy){ return [Math.floor(cx/zoom), Math.floor(cy/zoom)]; }

  // ===== Brush cursor =====
  function updateBrushCursorSize(){
    const d = Math.max(1, Math.round(brush * zoom));
    brushCursor.style.width = d + 'px';
    brushCursor.style.height = d + 'px';
  }
  function moveBrushCursor(evt){
    const rect = mapCanvas.getBoundingClientRect();
    const client = evt.touches ? evt.touches[0] : evt;
    const x = client.clientX - rect.left;
    const y = client.clientY - rect.top;
    const d = Math.max(1, Math.round(brush * zoom));
    brushCursor.style.left = Math.round(x - d/2) + 'px';
    brushCursor.style.top  = Math.round(y - d/2) + 'px';
  }
  mapCanvas.addEventListener('mouseenter', ()=> { brushCursor.style.display = 'block'; updateBrushCursorSize(); });
  mapCanvas.addEventListener('mouseleave', ()=> { brushCursor.style.display = 'none'; });

  // ===== Panning with spacebar + drag =====
  mapCanvas.addEventListener('mousedown', e=>{
    if(isSpace){
      panning = true;
      viewport.classList.add('dragging');
      panStartX = e.clientX; panStartY = e.clientY;
      panStartScrollL = viewport.scrollLeft; panStartScrollT = viewport.scrollTop;
    } else {
      startDrawing(e.offsetX, e.offsetY);
    }
  });
  mapCanvas.addEventListener('mousemove', e => {
    moveBrushCursor(e);
    if(panning){
      viewport.scrollLeft = panStartScrollL - (e.clientX - panStartX);
      viewport.scrollTop  = panStartScrollT  - (e.clientY - panStartY);
    } else if(drawing && shape==='freehand'){
      paintAt(e.offsetX, e.offsetY);
    } else if(previewing && (shape==='line' || shape==='rect' || shape==='measure')) {
      drawPreview(sx, sy, e.offsetX, e.offsetY);
    }
  });
  window.addEventListener('mouseup', e=>{
    if(panning){ panning=false; viewport.classList.remove('dragging'); }
    endDrawing(e);
  });

  // Touch (no spacebar on mobile — pan via viewport scroll as usual)
  mapCanvas.addEventListener('touchstart', e=>{
    if(!pgm) return;
    e.preventDefault();
    const t = e.touches[0], rect = mapCanvas.getBoundingClientRect();
    const x = t.clientX - rect.left, y = t.clientY - rect.top;
    moveBrushCursor(e);
    startDrawing(x, y);
  }, {passive:false});
  mapCanvas.addEventListener('touchmove', e => {
    if(!pgm) return;
    e.preventDefault();
    const t = e.touches[0];
    const rect = mapCanvas.getBoundingClientRect();
    const x = t.clientX - rect.left, y = t.clientY - rect.top;
    moveBrushCursor(e);
    if(drawing && shape==='freehand'){ paintAt(x, y); }
    else if(previewing && (shape==='line' || shape==='rect' || shape==='measure')){
      drawPreview(sx, sy, x, y);
    }
  }, {passive:false});
  mapCanvas.addEventListener('touchend', e=>{ e.preventDefault(); endDrawing(); }, {passive:false});
  mapCanvas.addEventListener('touchcancel', e=>{ e.preventDefault(); endDrawing(); }, {passive:false});

  // ===== Drawing lifecycle =====
  function startDrawing(cx, cy){
    if(!pgm) return;
    if(shape === 'freehand'){
      drawing = true;
      beginStroke();
      paintAt(cx, cy);
    } else if(shape === 'line' || shape === 'rect' || shape === 'measure'){
		// line / rect / measure: start preview
      previewing = true;
      sx = cx; sy = cy;
      clearPreview();
      drawPreview(sx, sy, cx, cy); // tiny marker
    }
  }
  
  function endDrawing(e){
    if(shape==='freehand'){
      if(!drawing) return;
      drawing = false;
      finishStroke();
    } else if(previewing){
      previewing = false;
	  // commit line/rect
      const rect = mapCanvas.getBoundingClientRect();
      let ex, ey;
      if(e && typeof e.clientX === 'number'){
        ex = e.clientX - rect.left; ey = e.clientY - rect.top;
      } else { 
		// if touchend or mouseup without coordinates, keep last previewed pos
		ex = lastPreviewX ?? sx; ey = lastPreviewY ?? sy;
      }
      if(shape === 'measure'){
        // keep the preview on screen until next action (comment out next line to persist it)
		setTimeout(() => { 
			clearPreview();	//clear it after few seconds
		}, 5000);
        return; // no pixel changes, no undo/redo entry
      }
      clearPreview();
      beginStroke();
      if(shape === 'line') drawThickLine(sx, sy, ex, ey);
      else if(shape === 'rect'){
        if(filledRect) drawFilledRect(sx, sy, ex, ey);
        else drawThickRect(sx, sy, ex, ey);
      }
      finishStroke();
    }
  }

  function beginStroke(){ currentStroke = []; touchedIndices = new Set(); }
  function finishStroke(){
    if(currentStroke && currentStroke.length){
      undoStack.push(currentStroke);
      if(undoStack.length > 100) undoStack.shift();
      // new action invalidates redo history
      redoStack.length = 0;
    }
    currentStroke = null; touchedIndices = null;
  }

  function undo(){
    const changeSet = undoStack.pop();
    if(!changeSet) return;
  
    // Apply the inverse (set each pixel back to its "prev"),
    // and stage a proper redo that will restore to "next".
    const redoSet = [];
    for (const ch of changeSet) {
      const buf = (ch.layer === 'pgm') ? pgm.pixels : mask;
      // current value should be ch.next; we revert to ch.prev
      buf[ch.idx] = ch.prev;
      // prepare redo to go back to NEXT (the drawn value)
      redoSet.push({ layer: ch.layer, idx: ch.idx, prev: ch.prev, next: ch.next });
    }
    redoStack.push(redoSet);
  
    redrawMap(); 
    redrawMask();
  }
  
  function redo(){
    const changeSet = redoStack.pop();
    if(!changeSet) return;
  
    // Re-apply the "next" values and push the same set back onto undo
    const undoSet = [];
    for (const ch of changeSet) {
      const buf = (ch.layer === 'pgm') ? pgm.pixels : mask;
      // current value should be ch.prev; we go to ch.next
      buf[ch.idx] = ch.next;
      // keep a proper undo record (same prev/next pair)
      undoSet.push({ layer: ch.layer, idx: ch.idx, prev: ch.prev, next: ch.next });
    }
    undoStack.push(undoSet);
  
    redrawMap(); 
    redrawMask();
  }

  // ===== Painting primitives =====
  function paintAt(cx, cy){
    if(!pgm) return;
    const [mx,my] = canvasToMap(cx, cy);
    const rad = Math.max(1, Math.floor(brush/2));
    const w = pgm.width, h = pgm.height, maxval = pgm.maxval;
  
    if(tool === 'mask'){
      paintBuffer('mask', mask, w, h, mx, my, rad, 0);
      redrawMask();
    } else if(tool === 'paint'){
      paintBuffer('pgm', pgm.pixels, w, h, mx, my, rad, 0);
      redrawMap();
    } else if(tool === 'erase'){
      paintBuffer('pgm', pgm.pixels, w, h, mx, my, rad, maxval);
      paintBuffer('mask', mask, w, h, mx, my, rad, 255);
      redrawMap(); redrawMask();
    } else if(tool === 'unscan'){
      paintBuffer('pgm', pgm.pixels, w, h, mx, my, rad, getUnknownVal());
      redrawMap();
    }
  }

  function paintBuffer(layerName, buf, w, h, mx, my, rad, value){
    for(let y = my-rad; y <= my+rad; y++){
      if(y < 0 || y >= h) continue;
      for(let x = mx-rad; x <= mx+rad; x++){
        if(x < 0 || x >= w) continue;
        const dx = x - mx, dy = y - my;
        if(dx*dx + dy*dy <= rad*rad){
          const idx = y*w + x;
          if(touchedIndices && !touchedIndices.has(idx)){
            currentStroke && currentStroke.push({layer: layerName, idx, prev: buf[idx], next: value});
            touchedIndices && touchedIndices.add(idx);
          }
          buf[idx] = value;
        }
      }
    }
  }
  
  // Return the pixel value that corresponds to #CDCDCD (205/255), scaled to current maxval
  function getUnknownVal(){
    const maxv = pgm ? pgm.maxval : 255;
    // 0xCD/255 ≈ 0.8039 → round to the nearest integer level of the PGM
    return Math.round(0.8039215686 * maxv);
  }

  function drawThickLine(cx1, cy1, cx2, cy2){
    let [x0,y0] = canvasToMap(cx1, cy1);
    let [x1,y1] = canvasToMap(cx2, cy2);
    const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
  
    const w = pgm.width, h = pgm.height, maxval = pgm.maxval;
    const rad = Math.max(1, Math.floor(brush/2));
    const unknown = getUnknownVal();
  
    const drawPoint = (mx,my)=>{
      if(tool==='paint')      paintBuffer('pgm', pgm.pixels, w,h, mx,my, rad, 0);
      else if(tool==='mask')  paintBuffer('mask', mask,       w,h, mx,my, rad, 0);
      else if(tool==='erase'){paintBuffer('pgm', pgm.pixels,  w,h, mx,my, rad, maxval);
                               paintBuffer('mask', mask,      w,h, mx,my, rad, 255);}
      else if(tool==='unscan'){paintBuffer('pgm', pgm.pixels, w,h, mx,my, rad, unknown);}
    };
  
    while(true){
      drawPoint(x0,y0);
      if(x0 === x1 && y0 === y1) break;
      const e2 = 2*err;
      if(e2 > -dy){ err -= dy; x0 += sx; }
      if(e2 <  dx){ err += dx; y0 += sy; }
    }
    redrawMap(); redrawMask();
  }

  function drawThickRect(cx1, cy1, cx2, cy2){
    // Normalize corners
    const x1 = Math.min(cx1, cx2), y1 = Math.min(cy1, cy2);
    const x2 = Math.max(cx1, cx2), y2 = Math.max(cy1, cy2);
    // Four edges
    drawThickLine(x1, y1, x2, y1); // top
    drawThickLine(x2, y1, x2, y2); // right
    drawThickLine(x2, y2, x1, y2); // bottom
    drawThickLine(x1, y2, x1, y1); // left
  }
  
  function drawFilledRect(cx1, cy1, cx2, cy2){
    // normalized canvas rectangle
    const x1 = Math.min(cx1, cx2), y1 = Math.min(cy1, cy2);
    const x2 = Math.max(cx1, cx2), y2 = Math.max(cy1, cy2);
  
    // Outline first (thick edges) — duplicates are OK; touchedIndices prevents double-logging
    drawThickRect(x1, y1, x2, y2);
  
    // Interior fill (map coords)
    const [mx1,my1] = canvasToMap(x1, y1);
    const [mx2,my2] = canvasToMap(x2, y2);
    const xMin = Math.max(0, Math.min(mx1, mx2));
    const yMin = Math.max(0, Math.min(my1, my2));
    const xMax = Math.min(pgm.width-1,  Math.max(mx1, mx2));
    const yMax = Math.min(pgm.height-1, Math.max(my1, my2));
  
    const w = pgm.width, maxval = pgm.maxval;
	const unknown = getUnknownVal();
  
    // Decide values per active tool
    const mapVal  = (tool==='paint') ? 0 : (tool==='erase' ? maxval : (tool==='unscan' ? unknown : null));
    const maskVal = (tool==='mask')  ? 0 : (tool==='erase' ? 255    : null);
  
    for(let y = yMin; y <= yMax; y++){
      const rowBase = y * w;
      for(let x = xMin; x <= xMax; x++){
        const idx = rowBase + x;
        if(mapVal  !== null) setPixelWithUndo('pgm',  pgm.pixels, idx, mapVal);
        if(maskVal !== null) setPixelWithUndo('mask', mask,       idx, maskVal);
      }
    }
  
    redrawMap();
    redrawMask();
  }
  
  // To account for Filled pixels in Undo
  function setPixelWithUndo(layerName, buf, idx, value){
    if(touchedIndices && !touchedIndices.has(idx)){
      currentStroke && currentStroke.push({ layer: layerName, idx, prev: buf[idx], next: value });
      touchedIndices.add(idx);
    }
    buf[idx] = value;
  }

  // ===== Preview overlay =====
  let lastPreviewX=null, lastPreviewY=null;

  function clearPreview(){
    prevCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    lastPreviewX=lastPreviewY=null;
  }
  
  // helper for label
  function drawLabel(ctx, x, y, text){
    ctx.save();
    ctx.font = Math.max(12, Math.round(12 * zoom)) + 'px Arial';
    ctx.textBaseline = 'bottom';
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
    ctx.fillStyle = 'white';
    ctx.strokeText(text, x+6, y-6);
    ctx.fillText(text, x+6, y-6);
    ctx.restore();
  }
  
  function drawPreview(cx1, cy1, cx2, cy2){
    clearPreview();
    lastPreviewX=cx2; lastPreviewY=cy2;
  
    prevCtx.save();
    prevCtx.lineWidth = Math.max(1, Math.round(brush * zoom));
    prevCtx.lineCap = 'round';
  
    if(shape==='line'){
      prevCtx.strokeStyle = (tool==='mask')   ? 'rgba(255,0,0,0.7)' :
							(tool==='erase')  ? 'rgba(255,255,255,0.85)' :
							(tool==='unscan') ? 'rgba(205,205,205,0.9)' :
												'rgba(0,0,0,0.85)';
      prevCtx.beginPath(); prevCtx.moveTo(cx1, cy1); prevCtx.lineTo(cx2, cy2); prevCtx.stroke();
    } else if(shape==='rect'){
      prevCtx.strokeStyle = (tool==='mask')   ? 'rgba(255,0,0,0.7)' :
							(tool==='erase')  ? 'rgba(255,255,255,0.85)' :
							(tool==='unscan') ? 'rgba(205,205,205,0.9)' :
												'rgba(0,0,0,0.85)';
      const x = Math.min(cx1,cx2), y = Math.min(cy1,cy2);
      const w = Math.abs(cx2-cx1), h = Math.abs(cy2-cy1);
      if(filledRect){
        // show a translucent fill preview
        prevCtx.fillStyle = (tool==='mask')   ? 'rgba(255,0,0,0.25)' :
						  (tool==='erase')  ? 'rgba(255,255,255,0.25)' :
						  (tool==='unscan') ? 'rgba(205,205,205,0.25)' :
											  'rgba(0,0,0,0.25)';
        prevCtx.fillRect(x, y, w, h);
      }
      prevCtx.strokeRect(x, y, w, h);
    } else if(shape==='measure'){
      // measuring: thin line + label (independent of brush)
      const lw = Math.max(1, Math.round(2 * zoom));
      prevCtx.lineWidth = lw;
      prevCtx.strokeStyle = 'rgba(0,150,255,0.9)';
      prevCtx.beginPath(); prevCtx.moveTo(cx1, cy1); prevCtx.lineTo(cx2, cy2); prevCtx.stroke();
      // distance
      const [mx1,my1] = canvasToMap(cx1, cy1);
      const [mx2,my2] = canvasToMap(cx2, cy2);
      const dx = mx2-mx1, dy = my2-my1;
      const pixDist = Math.sqrt(dx*dx + dy*dy);
      const res = (yamlObj && typeof yamlObj.resolution === 'number') ? yamlObj.resolution : 0.05; // meters/pixel
      const meters = pixDist * res;
      const feet = meters * 3.28084;
      const txt = `${meters.toFixed(3)} m  (${feet.toFixed(2)} ft)`;
      drawLabel(prevCtx, cx2, cy2, txt);
    }
  
    prevCtx.restore();
  }

  // ===== Loaders =====
  function handleFiles(fileList){
    const files = Array.from(fileList);
    if (files.length === 0) return;
  
    // quick index so _keepout.yaml can resolve its image from the same drop
    const byName = new Map(files.map(f => [f.name, f]));
  
    // First pass: YAML files (base or keepout)
    files.filter(f => isYaml(f.name)).forEach(file=>{
      readText(file).then(txt=>{
        try{
          const yobj = jsyaml.load(txt);
          // Decide base vs keepout by filename (and fall back to content hint)
          const isKO = isKeepoutName(file.name);
          if(isKO){
            // mask YAML: try to load its image from this batch
            const imgField = (yobj && yobj.image) ? String(yobj.image) : '';
            const baseName = imgField.split('/').pop();  // handle relative paths
            if(baseName && byName.has(baseName)){
              // load mask image from batch
              readBinary(byName.get(baseName)).then(buf=>{
                loadKeepoutPGM(baseName, new Uint8Array(buf));
              }).catch(err=> alert('Keepout image load error: ' + err.message));
            }else{
              // If baseName missing from the drop, just note it—user can drop it later
              console.warn('Drop the keepout image "'+ baseName +'" to view the mask.');
            }
            // Show YAML in preview if you want:
            // (Optional) $('#yamlPreview').text(txt);
          }else{
            // base map YAML
            yamlText = txt;
            yamlObj = yobj;
            yamlName = file.name;
            $('#yamlPreview').text(txt);
            $yamlName.text(file.name);
			updateDebug();
          }
        }catch(e){
          alert('YAML parse error in ' + file.name + ': ' + e.message);
        }
      });
    });
  
    // Second pass: PGM files (base or keepout)
    files.filter(f => isPgm(f.name)).forEach(file=>{
      readBinary(file).then(buf=>{
        const u8 = new Uint8Array(buf);
        if(isKeepoutName(file.name)){
          loadKeepoutPGM(file.name, u8);
        }else{
          loadBasePGM(file.name, u8);
        }
      }).catch(err=> alert('PGM parse error in ' + file.name + ': ' + err.message));
    });
  }
  function readText(file){
    return new Promise((res,rej)=>{
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.onerror = rej;
      fr.readAsText(file);
    });
  }
  function readBinary(file){
    return new Promise((res,rej)=>{
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.onerror = rej;
      fr.readAsArrayBuffer(file);
    });
  }
  
  function loadBasePGM(filename, u8){
    try{
      const parsed = parsePGM(u8);
      pgmName = filename;
      pgm = parsed;
      $pgmName.text(filename);
  
      // If mask not allocated or wrong size, reset/resize it to match the map
      if(!mask || (mask.length !== pgm.width*pgm.height)){
        mask = new Uint8ClampedArray(pgm.width*pgm.height);
        mask.fill(255); // no keepout by default
        maskName = 'No Keepout';
        $('#maskName').text(maskName);
      }
  
      setupCanvasFromPGM();  // this already redraws and updates dbg
    }catch(e){
      alert('Base PGM load error: ' + e.message);
    }
  }
  
  function loadKeepoutPGM(filename, u8){
    try{
      const kpgm = parsePGM(u8);
  
      // If we already have a base map, ensure sizes match
      if(pgm && (kpgm.width !== pgm.width || kpgm.height !== pgm.height)){
        alert(`Keepout mask size ${kpgm.width}x${kpgm.height} does not match base map ${pgm.width}x${pgm.height}. Skipping.`);
        return;
      }
  
      // Convert keepout to 0..255 (0=keepout, 255=no keepout)
      const total = kpgm.width * kpgm.height;
      const dst = new Uint8ClampedArray(total);
      const maxv = kpgm.maxval || 255;
  
      if(kpgm.pixels.BYTES_PER_ELEMENT === 1 && maxv === 255){
        // Fast path: already 8-bit
        dst.set(kpgm.pixels);
      }else{
        // Normalize to 8-bit
        for(let i=0;i<total;i++){
          dst[i] = Math.round((kpgm.pixels[i] * 255) / maxv);
        }
      }
  
      mask = dst;
      maskName = filename;
      $('#maskName').text(filename);
  
      // If base map not loaded yet, we still remember the mask;
      // once the map loads and canvases size, redraw will display it.
      if(pgm){
        // resize display canvases to current zoom if needed (already matched sizes)
        maskCanvas.width = Math.round(pgm.width * zoom);
        maskCanvas.height = Math.round(pgm.height * zoom);
        redrawMask();
      }
  
      // Debug line update
      updateDebug(); 
    }catch(e){
      alert('Keepout PGM load error: ' + e.message);
    }
  }

  function setupCanvasFromPGM(){
    if(!pgm) return;
    [mapCanvas, maskCanvas, previewCanvas].forEach(cv => { cv.width = Math.round(pgm.width*zoom); cv.height = Math.round(pgm.height*zoom); });
    redrawMap(); redrawMask(); clearPreview(); updateBrushCursorSize();

	updateDebug();
  }
  
  function updateDebug(){
    if(!pgm){
      $('#dbgInfo').text('—');
      return;
    }
    const keep = (typeof maskName === 'string' && maskName) ? maskName : 'No Keepout';
    const neg = (yamlObj && yamlObj.negate != null) ? yamlObj.negate : '(n/a)';
    $('#dbgInfo').text(
      `PGM: ${pgm.width}×${pgm.height}, maxval=${pgm.maxval}, magic=${pgm.magic}; ` +
      `YAML negate=${neg}; Keepout: ${keep}`
    );
  }

  // ===== Rendering =====
  function redrawMap(){
    if(!pgm) return;
    const {width:w, height:h, pixels, maxval} = pgm;
    if(!w || !h || !maxval) return;

    let pmin = 65535, pmax = 0;
    if($('#autoLevels').prop('checked')){
      for(let i=0;i<w*h;i++){ const v=pixels[i]; if(v<pmin) pmin=v; if(v>pmax) pmax=v; }
      if(pmax === pmin){ pmin=0; pmax=maxval; }
    } else { pmin=0; pmax=maxval; }

    const inv = $('#invertDisplay').prop('checked') || (yamlObj && Number(yamlObj.negate) === 1);
    const img = mapCtx.createImageData(w, h);
    const sc = (pmax > pmin) ? (255 / (pmax - pmin)) : 1;

    for(let i=0;i<w*h;i++){
      let g = Math.round((pixels[i] - pmin) * sc);
      if(g<0) g=0; else if(g>255) g=255;
      if(inv) g = 255 - g;
      img.data[4*i+0] = g; img.data[4*i+1] = g; img.data[4*i+2] = g; img.data[4*i+3] = 255;
    }
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    tmp.getContext('2d').putImageData(img,0,0);
    mapCtx.imageSmoothingEnabled = false;
    mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
    mapCtx.drawImage(tmp, 0,0, mapCanvas.width, mapCanvas.height);
  }

  function redrawMask(){
    if(!pgm || !mask) return;
    const {width:w, height:h} = pgm;
    const img = maskCtx.createImageData(w, h);
    for(let i=0;i<w*h;i++){
      const m = mask[i];      // 0..255
      const isKO = (m <= 20);
      img.data[4*i+0] = isKO ? 255 : 0;
      img.data[4*i+1] = 0;
      img.data[4*i+2] = 0;
      img.data[4*i+3] = isKO ? 120 : 0;
    }
    const tmp = document.createElement('canvas');
    tmp.width = w; tmp.height = h;
    tmp.getContext('2d').putImageData(img,0,0);
    maskCtx.imageSmoothingEnabled = false;
    maskCtx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
    maskCtx.drawImage(tmp, 0,0, maskCanvas.width, maskCanvas.height);
  }

  // ===== PGM parsing/encoding =====
  function parsePGM(uint8){
    const textHead = new TextDecoder().decode(uint8.slice(0, 1024));
    const magic = textHead.slice(0,2);
    if(magic !== 'P5' && magic !== 'P2') throw new Error('Unsupported PGM magic');

    function* tokens(bytes){
      let s = '';
      for(let i=0;i<bytes.length;i++){
        const c = String.fromCharCode(bytes[i]);
        if(c==='#'){ while(i<bytes.length && String.fromCharCode(bytes[i])!=='\n') i++; continue; }
        if(/\s/.test(c)){ if(s.length){ yield s; s=''; } } else s+=c;
        if(s.length>256) throw new Error('Header token too long');
      } if(s.length) yield s;
    }
    const it = tokens(uint8);
    const mg = it.next().value; if(mg !== magic) throw new Error('Malformed header');
    const w = parseInt(it.next().value,10);
    const h = parseInt(it.next().value,10);
    const maxv = parseInt(it.next().value,10);
    if(!(w>0 && h>0 && maxv>0)) throw new Error('Invalid pgm dims/maxval');

    if(magic === 'P2'){
      const restTxt = new TextDecoder().decode(uint8);
      const headerRe = new RegExp(`^\\s*${magic}[\\s\\S]*?\\b${maxv}\\b`);
      const headerMatch = restTxt.match(headerRe);
      const start = headerMatch ? headerMatch[0].length : 0;
      const nums = restTxt.slice(start).match(/\d+/g) || [];
      if(nums.length < w*h) throw new Error('P2 data too short');
      const pixels = new Uint16Array(w*h);
      for(let i=0;i<w*h;i++) pixels[i] = Math.min(maxv, parseInt(nums[i],10));
      return {magic, width:w, height:h, maxval:maxv, pixels};
    }else{
      // After maxval, first non-ws is raster
      let nums=0, i=2, inTok=false;
      while(i < uint8.length && nums < 3){
        const c = uint8[i];
        if(c === 35){ while(i<uint8.length && uint8[i]!==10) i++; }
        else if(c > 32){ if(!inTok){ inTok=true; nums++; } }
        else{ if(inTok){ inTok=false; } }
        i++;
      }
      while(i < uint8.length && uint8[i] <= 32) i++;
      const dataStart = i;

      const pixels = (maxv>255) ? new Uint16Array(w*h) : new Uint8Array(w*h);
      const bytesPer = (maxv>255)?2:1;
      const needed = w*h*bytesPer;
      if(dataStart + needed > uint8.length) throw new Error('P5 data too short');
      if(bytesPer===1){ pixels.set(uint8.slice(dataStart, dataStart+needed)); }
      else{
        let p=0; for(let k=0;k<needed;k+=2){ pixels[p++] = (uint8[dataStart+k]<<8) | uint8[dataStart+k+1]; }
      }
      return {magic, width:w, height:h, maxval:maxv, pixels};
    }
  }

  function encodePGM(pgm){
    const {width:w, height:h, maxval, pixels} = pgm;
    const header = `P5\n${w} ${h}\n${maxval}\n`;
    const enc = new TextEncoder();
    const hbytes = enc.encode(header);
    const bytesPer = (maxval>255)?2:1;
    const body = new Uint8Array(w*h*bytesPer);
    if(bytesPer===1){ for(let i=0;i<w*h;i++) body[i] = Math.min(255, pixels[i]); }
    else{
      let j=0; for(let i=0;i<w*h;i++){ const v = pixels[i]; body[j++] = (v>>8)&0xFF; body[j++] = v & 0xFF; }
    }
    const out = new Uint8Array(hbytes.length + body.length);
    out.set(hbytes,0); out.set(body,hbytes.length);
    return out;
  }

  // ===== Downloads =====
  function dlBytes(bytes, filename, mime='application/octet-stream'){
    const blob = new Blob([bytes], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  }
  function dlText(txt, filename, mime='text/yaml'){
    const blob = new Blob([txt], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  }
  function buildUpdatedYaml(imageName){
    if(!yamlObj) return '';
    const y = Object.assign({}, yamlObj, { image: imageName });
    return jsyaml.dump(y);
  }

  $('#btnDownloadMap').on('click', ()=>{
    if(!pgm || !yamlObj){ alert('Load YAML and PGM first.'); return; }
    const pgmBytes = encodePGM(pgm);
    const outPgm = pgmName.replace(/\.pgm$/i,'_edited.pgm');
    const outYaml = (yamlName||'map.yaml').replace(/\.ya?ml$/i,'_edited.yaml');
    dlBytes(pgmBytes, outPgm, 'image/x-portable-graymap');
    dlText(buildUpdatedYaml(outPgm), outYaml, 'text/yaml');
  });

  $('#btnDownloadMask').on('click', ()=>{
    if(!pgm || !yamlObj || !mask){ alert('Load YAML and PGM first.'); return; }
    const m = { magic:'P5', width: pgm.width, height: pgm.height, maxval: 255, pixels: mask };
    const maskBytes = encodePGM(m);
    const base = (pgmName||'map.pgm').replace(/\.pgm$/i,'');
    const outMaskPgm = base + '_keepout.pgm';
    const outMaskYaml = base + '_keepout.yaml';
    const y = Object.assign({}, yamlObj, { image: outMaskPgm });
    dlBytes(maskBytes, outMaskPgm, 'image/x-portable-graymap');
    dlText(jsyaml.dump(y), outMaskYaml, 'text/yaml');
  });

})();
</script>
</body>
</html>
